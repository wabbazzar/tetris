<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    
    <!-- Cache-busting headers -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Mobile-specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Tetris Turbo">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <title>Tetris Turbo - Mobile Edition</title>
    
    <style>
        /* Mobile-first Tron aesthetic */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000000;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            touch-action: manipulation;
            /* Safe area handling for iPhone */
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            padding: 10px;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
            gap: 8px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrolling and cutoff */
            width: 100%;
            position: relative;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .score-level-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .mobile-next-piece {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }
        
        .next-piece-label-mobile {
            color: #00ffff;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 0 0 5px #00ffff;
        }
        
        .next-piece-preview-mobile {
            width: 45px;
            height: 45px;
            position: relative;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .next-piece-container {
            margin-top: 20px;
        }
        
        .next-piece-label {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 8px;
        }
        
        .next-piece-preview {
            width: 80px;
            height: 80px;
            position: relative;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .preview-cell {
            position: absolute;
            border: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .preview-cell.filled {
            border: 1px solid currentColor;
            box-shadow: 0 0 3px currentColor;
        }
        
        .game-board {
            flex: 1;
            max-width: 100%;
            margin: 0 auto;
            border: 2px solid #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff;
            position: relative;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.8);
            box-sizing: border-box;
            min-height: 0; /* Allow proper shrinking */
        }
        

        
        .game-info {
            display: none; /* Hidden on mobile, moved to header */
        }
        
        .score-display {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: clamp(14px, 4vw, 18px);
            font-weight: bold;
        }
        
        .level-display {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-size: clamp(14px, 4vw, 18px);
            font-weight: bold;
        }
        

        
        .version-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #666;
            font-size: 10px;
        }
        
        /* Responsive grid cell styles */
        .cell {
            position: absolute;
            border: 1px solid rgba(0, 255, 255, 0.1);
            transition: all 0.1s ease;
        }
        
        .cell.filled {
            border: 1px solid currentColor;
            box-shadow: 0 0 5px currentColor;
        }
        
        /* Desktop breakpoint */
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                justify-content: center;
                align-items: center;
                padding: 20px;
            }
            
            .game-header {
                display: none;
            }
            
            .game-board {
                width: 300px;
                height: 600px;
                flex: none;
            }
            
            .game-info {
                display: flex;
                flex-direction: column;
                gap: 20px;
                min-width: 200px;
            }
            

            
            .score-display,
            .level-display {
                font-size: 18px;
            }
        }
        
        /* Piece colors with glow effects */
        .cyan { color: #00ffff; background: rgba(0, 255, 255, 0.3); }
        .orange { color: #ff6600; background: rgba(255, 102, 0, 0.3); }
        .green { color: #00ff00; background: rgba(0, 255, 0, 0.3); }
        .pink { color: #ff0099; background: rgba(255, 0, 153, 0.3); }
        .blue { color: #0099ff; background: rgba(0, 153, 255, 0.3); }
        .yellow { color: #ffff00; background: rgba(255, 255, 0, 0.3); }
        .purple { color: #9900ff; background: rgba(153, 0, 255, 0.3); }
        
        /* Zone feedback animation */
        @keyframes zoneFeedback {
            0% {
                transform: scale(0.5);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Mobile header with score/level and next piece -->
        <div class="game-header">
            <div class="score-level-container">
                <div class="score-display">
                    SCORE: <span id="score">0</span>
                </div>
                <div class="level-display">
                    LEVEL: <span id="level">1</span>
                </div>
            </div>
            
            <!-- Next piece preview for mobile -->
            <div class="mobile-next-piece">
                <div class="next-piece-label-mobile">NEXT</div>
                <div class="next-piece-preview-mobile" id="nextPiecePreviewMobile">
                    <!-- 3x3 mini-grid for next piece -->
                </div>
            </div>
        </div>
        
        <!-- Game board -->
        <div class="game-board" id="gameBoard">
            <!-- Grid cells will be generated here -->
        </div>
        

        
        <!-- Desktop info panel (hidden on mobile) -->
        <div class="game-info">
            <div class="score-display">
                SCORE: <span id="scoreDesktop">0</span>
            </div>
            <div class="level-display">
                LEVEL: <span id="levelDesktop">1</span>
            </div>
            
            <!-- Next piece preview for desktop -->
            <div class="next-piece-container">
                <div class="next-piece-label">NEXT:</div>
                <div class="next-piece-preview" id="nextPiecePreview">
                    <!-- 4x4 mini-grid for next piece -->
                </div>
            </div>
            
            <div class="controls" style="color: #666; font-size: 12px; margin-top: 20px;">
                <div>CONTROLS:</div>
                <div>← → ↓ ↑ : Move/Rotate</div>
                <div>A W S D : Move/Rotate</div>
                <div>SPACE : Hard Drop</div>
                <div>P : Pause</div>
                <div>R : Restart</div>
            </div>
        </div>
    </div>
    
    <div class="version-info">
        Tetris Turbo v1.0.0 - Cache Bust: tetris_turbo_v1_<?php echo time(); ?>
    </div>

    <script>
        // Game state and configuration
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        let CELL_SIZE = 30; // Dynamic cell size for mobile
        let isMobile = false;
        
        // Game board state array
        let board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null));
        
        // Game state
        let score = 0;
        let level = 1;
        let gameRunning = false;
        let currentPiece = null;
        let nextPiece = null;
        let gameLoop = null;
        
        // Tetris piece definitions with rotations
        const PIECES = {
            I: {
                color: 'cyan',
                rotations: [
                    [[1,1,1,1]],
                    [[1],[1],[1],[1]],
                    [[1,1,1,1]],
                    [[1],[1],[1],[1]]
                ]
            },
            O: {
                color: 'orange',
                rotations: [
                    [[1,1],[1,1]],
                    [[1,1],[1,1]],
                    [[1,1],[1,1]],
                    [[1,1],[1,1]]
                ]
            },
            T: {
                color: 'green',
                rotations: [
                    [[0,1,0],[1,1,1]],
                    [[1,0],[1,1],[1,0]],
                    [[1,1,1],[0,1,0]],
                    [[0,1],[1,1],[0,1]]
                ]
            },
            S: {
                color: 'pink',
                rotations: [
                    [[0,1,1],[1,1,0]],
                    [[1,0],[1,1],[0,1]],
                    [[0,1,1],[1,1,0]],
                    [[1,0],[1,1],[0,1]]
                ]
            },
            Z: {
                color: 'blue',
                rotations: [
                    [[1,1,0],[0,1,1]],
                    [[0,1],[1,1],[1,0]],
                    [[1,1,0],[0,1,1]],
                    [[0,1],[1,1],[1,0]]
                ]
            },
            J: {
                color: 'yellow',
                rotations: [
                    [[1,0,0],[1,1,1]],
                    [[1,1],[1,0],[1,0]],
                    [[1,1,1],[0,0,1]],
                    [[0,1],[0,1],[1,1]]
                ]
            },
            L: {
                color: 'purple',
                rotations: [
                    [[0,0,1],[1,1,1]],
                    [[1,0],[1,0],[1,1]],
                    [[1,1,1],[1,0,0]],
                    [[1,1],[0,1],[0,1]]
                ]
            }
        };
        
        // Version tracking for cache debugging
        console.log('Tetris Turbo Mobile loaded - Version 2.0.0');
        console.log('Cache Bust ID: tetris_turbo_mobile_v2');
        console.log('Piece definitions loaded:', Object.keys(PIECES).length, 'pieces');
        
        // Mobile detection and initialization
        function initializeMobile() {
            // Detect mobile device
            isMobile = window.innerWidth < 768 || ('ontouchstart' in window);
            
            // Calculate responsive cell size for mobile
            if (isMobile) {
                const gameBoard = document.getElementById('gameBoard');
                
                // More precise mobile dimension calculation
                const containerPadding = 20; // Total horizontal padding (10px each side)
                const availableWidth = window.innerWidth - containerPadding;
                const headerHeight = 80; // Header space
                const versionInfoHeight = 20; // Version info at bottom
                const safeAreaBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-inset-bottom') || '0');
                const totalVerticalPadding = 20; // Container padding
                
                const availableHeight = window.innerHeight - headerHeight - versionInfoHeight - safeAreaBottom - totalVerticalPadding;
                
                // Calculate cell sizes more precisely
                const cellSizeByWidth = Math.floor(availableWidth / BOARD_WIDTH);
                const cellSizeByHeight = Math.floor(availableHeight / BOARD_HEIGHT);
                
                // Use the larger possible size to maximize grid utilization
                CELL_SIZE = Math.min(cellSizeByWidth, cellSizeByHeight, 35); // Increased max size
                
                // Calculate actual board dimensions
                const boardWidth = BOARD_WIDTH * CELL_SIZE;
                const boardHeight = BOARD_HEIGHT * CELL_SIZE;
                
                // Center the board horizontally if there's extra space
                const leftMargin = Math.floor((availableWidth - boardWidth) / 2);
                
                // Update game board size and position
                gameBoard.style.width = boardWidth + 'px';
                gameBoard.style.height = boardHeight + 'px';
                gameBoard.style.marginLeft = leftMargin + 'px';
                gameBoard.style.marginRight = leftMargin + 'px';
                
                console.log('Mobile layout optimized:');
                console.log('- Screen size:', window.innerWidth + 'x' + window.innerHeight);
                console.log('- Available space:', availableWidth + 'x' + availableHeight);
                console.log('- Cell size:', CELL_SIZE + 'px');
                console.log('- Board size:', boardWidth + 'x' + boardHeight);
                console.log('- Horizontal margins:', leftMargin + 'px');
            }
            
            return isMobile;
        }
        
        // Single method for updating mobile layout
        function updateMobileLayout() {
            if (!isMobile) return;
            
            // Update all cell positions with new size
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    if (cell) {
                        cell.style.left = (col * CELL_SIZE) + 'px';
                        cell.style.top = (row * CELL_SIZE) + 'px';
                        cell.style.width = CELL_SIZE + 'px';
                        cell.style.height = CELL_SIZE + 'px';
                    }
                }
            }
        }
        
        // Initialize the game board
        function initializeBoard() {
            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            
            // Initialize mobile layout first
            initializeMobile();
            
            // Create 10x20 grid with responsive sizing
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${row}-${col}`;
                    cell.style.left = (col * CELL_SIZE) + 'px';
                    cell.style.top = (row * CELL_SIZE) + 'px';
                    cell.style.width = CELL_SIZE + 'px';
                    cell.style.height = CELL_SIZE + 'px';
                    gameBoard.appendChild(cell);
                }
            }
            
            // Initialize next piece preview grids
            initializeNextPiecePreview();
            
            console.log('Game board initialized with', BOARD_WIDTH * BOARD_HEIGHT, 'cells');
            console.log('Mobile mode:', isMobile, '| Cell size:', CELL_SIZE + 'px');
        }
        
        // Initialize next piece preview grids
        function initializeNextPiecePreview() {
            // Desktop preview (4x4 grid)
            const desktopPreview = document.getElementById('nextPiecePreview');
            if (desktopPreview) {
                desktopPreview.innerHTML = '';
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'preview-cell';
                        cell.id = `preview-${row}-${col}`;
                        cell.style.left = (col * 20) + 'px';
                        cell.style.top = (row * 20) + 'px';
                        cell.style.width = '20px';
                        cell.style.height = '20px';
                        desktopPreview.appendChild(cell);
                    }
                }
            }
            
            // Mobile preview (3x3 grid)
            const mobilePreview = document.getElementById('nextPiecePreviewMobile');
            if (mobilePreview) {
                mobilePreview.innerHTML = '';
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'preview-cell';
                        cell.id = `preview-mobile-${row}-${col}`;
                        cell.style.left = (col * 15) + 'px';
                        cell.style.top = (row * 15) + 'px';
                        cell.style.width = '15px';
                        cell.style.height = '15px';
                        mobilePreview.appendChild(cell);
                    }
                }
            }
        }
        
        // Update next piece preview
        function updateNextPiecePreview() {
            if (!nextPiece) return;
            
            // Clear both previews
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const desktopCell = document.getElementById(`preview-${row}-${col}`);
                    if (desktopCell) {
                        desktopCell.className = 'preview-cell';
                        desktopCell.style.background = '';
                    }
                }
            }
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const mobileCell = document.getElementById(`preview-mobile-${row}-${col}`);
                    if (mobileCell) {
                        mobileCell.className = 'preview-cell';
                        mobileCell.style.background = '';
                    }
                }
            }
            
            // Draw next piece in both previews
            const shape = PIECES[nextPiece.type].rotations[0];
            const color = PIECES[nextPiece.type].color;
            
            // Calculate centering offset
            const desktopOffsetX = Math.floor((4 - shape[0].length) / 2);
            const desktopOffsetY = Math.floor((4 - shape.length) / 2);
            const mobileOffsetX = Math.floor((3 - shape[0].length) / 2);
            const mobileOffsetY = Math.floor((3 - shape.length) / 2);
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        // Desktop preview
                        const desktopRow = row + desktopOffsetY;
                        const desktopCol = col + desktopOffsetX;
                        if (desktopRow >= 0 && desktopRow < 4 && desktopCol >= 0 && desktopCol < 4) {
                            const desktopCell = document.getElementById(`preview-${desktopRow}-${desktopCol}`);
                            if (desktopCell) {
                                desktopCell.className = `preview-cell filled ${color}`;
                            }
                        }
                        
                        // Mobile preview (only if fits in 3x3)
                        const mobileRow = row + mobileOffsetY;
                        const mobileCol = col + mobileOffsetX;
                        if (mobileRow >= 0 && mobileRow < 3 && mobileCol >= 0 && mobileCol < 3) {
                            const mobileCell = document.getElementById(`preview-mobile-${mobileRow}-${mobileCol}`);
                            if (mobileCell) {
                                mobileCell.className = `preview-cell filled ${color}`;
                            }
                        }
                    }
                }
            }
        }
        
        // Single method for updating cells (following testing requirements)
        function updateCell(row, col, color = null, glow = false) {
            const cell = document.getElementById(`cell-${row}-${col}`);
            if (!cell) return false;
            
            // Clear previous classes
            cell.className = 'cell';
            
            if (color) {
                cell.classList.add('filled', color);
                board[row][col] = color;
            } else {
                board[row][col] = null;
            }
            
            return true;
        }
        
        // Single method for rendering the entire board (batch updates)
        function renderBoard() {
            const startTime = performance.now();
            let updatedCells = 0;
            
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    if (updateCell(row, col, board[row][col])) {
                        updatedCells++;
                    }
                }
            }
            
            // Force repaint for smooth rendering
            document.getElementById('gameBoard').offsetHeight;
            
            const endTime = performance.now();
            console.log(`Board rendered: ${updatedCells} cells in ${(endTime - startTime).toFixed(2)}ms`);
        }
        
        // Create a new random piece
        function createPiece() {
            const pieceTypes = Object.keys(PIECES);
            const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
            
            return {
                type: randomType,
                rotation: 0,
                x: Math.floor(BOARD_WIDTH / 2) - 1,
                y: 0,
                shape: PIECES[randomType].rotations[0],
                color: PIECES[randomType].color
            };
        }
        
        // Draw a piece on the board (visual representation)
        function drawPiece(piece, x, y) {
            if (!piece) return;
            
            const shape = PIECES[piece.type].rotations[piece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH) {
                            updateCell(boardRow, boardCol, piece.color);
                        }
                    }
                }
            }
        }
        
        // Clear a piece from the board
        function clearPiece(piece, x, y) {
            if (!piece) return;
            
            const shape = PIECES[piece.type].rotations[piece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH &&
                            board[boardRow][boardCol] === piece.color) {
                            updateCell(boardRow, boardCol, null);
                        }
                    }
                }
            }
        }
        
        // Check if a piece can be placed at a position
        function canPlacePiece(piece, x, y, rotation = null) {
            if (!piece) return false;
            
            const currentRotation = rotation !== null ? rotation : piece.rotation;
            const shape = PIECES[piece.type].rotations[currentRotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        // Check boundaries
                        if (boardRow < 0 || boardRow >= BOARD_HEIGHT || 
                            boardCol < 0 || boardCol >= BOARD_WIDTH) {
                            return false;
                        }
                        
                        // Check collision with existing pieces
                        if (board[boardRow][boardCol] !== null) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Update score display (mobile and desktop)
        function updateScore(newScore = null) {
            if (newScore !== null) {
                score = newScore;
            }
            
            // Update mobile score
            const mobileScore = document.getElementById('score');
            if (mobileScore) {
                mobileScore.textContent = score;
            }
            
            // Update desktop score
            const desktopScore = document.getElementById('scoreDesktop');
            if (desktopScore) {
                desktopScore.textContent = score;
            }
        }
        
        // Update level display (mobile and desktop)
        function updateLevel(newLevel = null) {
            if (newLevel !== null) {
                level = newLevel;
            }
            
            // Update mobile level
            const mobileLevel = document.getElementById('level');
            if (mobileLevel) {
                mobileLevel.textContent = level;
            }
            
            // Update desktop level
            const desktopLevel = document.getElementById('levelDesktop');
            if (desktopLevel) {
                desktopLevel.textContent = level;
            }
        }
        
        // Single method for moving pieces (following testing requirements)
        function movePiece(dx, dy) {
            if (!currentPiece || !gameRunning) return false;
            
            // Clear current piece from board
            clearPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            const newX = currentPiece.x + dx;
            const newY = currentPiece.y + dy;
            
            if (canPlacePiece(currentPiece, newX, newY)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return true;
            } else {
                // Can't move, restore piece
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                
                // If trying to move down and can't, lock the piece
                if (dy > 0) {
                    lockPiece();
                }
                return false;
            }
        }
        
        // Rotate the current piece
        function rotatePiece() {
            if (!currentPiece || !gameRunning) return false;
            
            clearPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            const newRotation = (currentPiece.rotation + 1) % 4;
            
            if (canPlacePiece(currentPiece, currentPiece.x, currentPiece.y, newRotation)) {
                currentPiece.rotation = newRotation;
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return true;
            } else {
                // Try wall kicks (move left/right if rotation blocked)
                for (let kick of [-1, 1, -2, 2]) {
                    if (canPlacePiece(currentPiece, currentPiece.x + kick, currentPiece.y, newRotation)) {
                        currentPiece.x += kick;
                        currentPiece.rotation = newRotation;
                        drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                        return true;
                    }
                }
                
                // Couldn't rotate, restore piece
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return false;
            }
        }
        
        // Hard drop - instant placement
        function hardDrop() {
            if (!currentPiece || !gameRunning) return;
            
            while (movePiece(0, 1)) {
                // Keep moving down until we can't
            }
            // movePiece will automatically call lockPiece when it can't move down
        }
        
        // Lock current piece in place and spawn new piece
        function lockPiece() {
            if (!currentPiece) return;
            
            // Piece is already drawn on board, just update the board array
            const shape = PIECES[currentPiece.type].rotations[currentPiece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = currentPiece.y + row;
                        const boardCol = currentPiece.x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH) {
                            board[boardRow][boardCol] = currentPiece.color;
                        }
                    }
                }
            }
            
            // Check for completed lines
            checkLines();
            
            // Spawn new piece
            currentPiece = nextPiece || createPiece();
            nextPiece = createPiece();
            
            // Update next piece preview
            updateNextPiecePreview();
            
            // Check game over
            if (!canPlacePiece(currentPiece, currentPiece.x, currentPiece.y)) {
                gameOver();
                return;
            }
            
            drawPiece(currentPiece, currentPiece.x, currentPiece.y);
        }
        
        // Check for completed lines
        function checkLines() {
            const completedLines = [];
            
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                if (board[row].every(cell => cell !== null)) {
                    completedLines.push(row);
                }
            }
            
            if (completedLines.length > 0) {
                // Clear completed lines
                completedLines.forEach(row => {
                    board.splice(row, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(null));
                });
                
                // Update score
                const points = [0, 100, 300, 500, 800][completedLines.length] * level;
                updateScore(score + points);
                
                // Check level progression
                const newLevel = Math.floor(score / 1000) + 1;
                if (newLevel !== level) {
                    updateLevel(newLevel);
                }
                
                // Re-render board after line clear
                renderBoard();
                
                console.log(`Cleared ${completedLines.length} lines, +${points} points`);
            }
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
            console.log('Game Over! Final Score:', score);
            // TODO: Add game over screen
        }
        
        // Start new game
        function startGame() {
            // Reset game state
            board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null));
            score = 0;
            level = 1;
            updateScore();
            updateLevel();
            
            // Create first pieces
            currentPiece = createPiece();
            nextPiece = createPiece();
            
            // Update next piece preview
            updateNextPiecePreview();
            
            gameRunning = true;
            
            // Clear board and draw first piece
            renderBoard();
            drawPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            // Start game loop
            gameLoop = requestAnimationFrame(gameUpdate);
            
            console.log('Game started!');
        }
        
        // Game timing variables
        let lastDrop = 0;
        
        // Main game loop
        function gameUpdate() {
            if (!gameRunning) return;
            
            // Auto-drop logic
            const now = Date.now();
            const dropInterval = Math.max(100, 1000 - (level - 1) * 100);
            
            if (now - lastDrop > dropInterval) {
                movePiece(0, 1);
                lastDrop = now;
            }
            
            gameLoop = requestAnimationFrame(gameUpdate);
        }
        
        // Keyboard input handling
        function handleKeyDown(event) {
            if (!gameRunning) {
                if (event.key === 'r' || event.key === 'R') {
                    startGame();
                }
                return;
            }
            
            switch(event.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    event.preventDefault();
                    movePiece(-1, 0);
                    break;
                    
                case 'ArrowRight':
                case 'd':
                case 'D':
                    event.preventDefault();
                    movePiece(1, 0);
                    break;
                    
                case 'ArrowDown':
                case 's':
                case 'S':
                    event.preventDefault();
                    movePiece(0, 1);
                    break;
                    
                case 'ArrowUp':
                case 'w':
                case 'W':
                    event.preventDefault();
                    rotatePiece();
                    break;
                    
                case ' ':
                    event.preventDefault();
                    hardDrop();
                    break;
                    
                case 'p':
                case 'P':
                    event.preventDefault();
                    gameRunning = !gameRunning;
                    if (gameRunning) {
                        gameLoop = requestAnimationFrame(gameUpdate);
                    } else if (gameLoop) {
                        cancelAnimationFrame(gameLoop);
                        gameLoop = null;
                    }
                    console.log(gameRunning ? 'Game unpaused' : 'Game paused');
                    break;
                    
                case 'r':
                case 'R':
                    event.preventDefault();
                    startGame();
                    break;
            }
        }
        
        // Setup mobile zone-based controls
        function setupMobileControls() {
            if (!isMobile) return;
            
            // Setup zone-based touch controls
            setupZoneBasedControls();
            
            console.log('Mobile zone-based controls setup complete');
        }
        
        // Zone-based touch control system
        function setupZoneBasedControls() {
            const gameContainer = document.querySelector('.game-container');
            let touchStartTime = 0;
            let touchStartPos = { x: 0, y: 0 };
            let longPressTimer = null;
            let lastTapTime = 0;
            let singleTapTimer = null;
            
            // Get zone boundaries
            function getZoneBoundaries() {
                const gameBoard = document.getElementById('gameBoard');
                const boardRect = gameBoard.getBoundingClientRect();
                const containerRect = gameContainer.getBoundingClientRect();
                
                return {
                    gameBoard: {
                        left: boardRect.left,
                        right: boardRect.right,
                        top: boardRect.top,
                        bottom: boardRect.bottom
                    },
                    leftZone: {
                        left: containerRect.left,
                        right: boardRect.left,
                        top: containerRect.top,
                        bottom: containerRect.bottom
                    },
                    rightZone: {
                        left: boardRect.right,
                        right: containerRect.right,
                        top: containerRect.top,
                        bottom: containerRect.bottom
                    },
                    bottomZone: {
                        left: containerRect.left,
                        right: containerRect.right,
                        top: boardRect.bottom,
                        bottom: containerRect.bottom
                    }
                };
            }
            
            // Determine which zone was touched
            function getTouchZone(x, y) {
                const zones = getZoneBoundaries();
                
                // Check if touch is within game board
                if (x >= zones.gameBoard.left && x <= zones.gameBoard.right &&
                    y >= zones.gameBoard.top && y <= zones.gameBoard.bottom) {
                    return 'grid';
                }
                
                // Check left zone
                if (x >= zones.leftZone.left && x <= zones.leftZone.right &&
                    y >= zones.leftZone.top && y <= zones.leftZone.bottom) {
                    return 'left';
                }
                
                // Check right zone
                if (x >= zones.rightZone.left && x <= zones.rightZone.right &&
                    y >= zones.rightZone.top && y <= zones.rightZone.bottom) {
                    return 'right';
                }
                
                // Check bottom zone
                if (x >= zones.bottomZone.left && x <= zones.bottomZone.right &&
                    y >= zones.bottomZone.top && y <= zones.bottomZone.bottom) {
                    return 'bottom';
                }
                
                return 'outside';
            }
            
            // Add visual feedback for zone touches
            function showZoneFeedback(zone, x, y) {
                const feedback = document.createElement('div');
                feedback.className = `zone-feedback zone-${zone}`;
                feedback.style.position = 'fixed';
                feedback.style.left = (x - 20) + 'px';
                feedback.style.top = (y - 20) + 'px';
                feedback.style.width = '40px';
                feedback.style.height = '40px';
                feedback.style.borderRadius = '50%';
                feedback.style.pointerEvents = 'none';
                feedback.style.zIndex = '1000';
                feedback.style.opacity = '0.8';
                feedback.style.animation = 'zoneFeedback 0.3s ease-out forwards';
                
                if (zone === 'grid') {
                    feedback.style.background = 'radial-gradient(circle, rgba(0,255,255,0.6) 0%, rgba(0,255,255,0) 70%)';
                } else if (zone === 'left') {
                    feedback.style.background = 'radial-gradient(circle, rgba(255,0,153,0.6) 0%, rgba(255,0,153,0) 70%)';
                    feedback.innerHTML = '←';
                    feedback.style.color = '#ff0099';
                    feedback.style.fontSize = '20px';
                    feedback.style.textAlign = 'center';
                    feedback.style.lineHeight = '40px';
                } else if (zone === 'right') {
                    feedback.style.background = 'radial-gradient(circle, rgba(0,255,0,0.6) 0%, rgba(0,255,0,0) 70%)';
                    feedback.innerHTML = '→';
                    feedback.style.color = '#00ff00';
                    feedback.style.fontSize = '20px';
                    feedback.style.textAlign = 'center';
                    feedback.style.lineHeight = '40px';
                } else if (zone === 'bottom') {
                    feedback.style.background = 'radial-gradient(circle, rgba(255,255,0,0.6) 0%, rgba(255,255,0,0) 70%)';
                    feedback.innerHTML = '⬇⬇';
                    feedback.style.color = '#ffff00';
                    feedback.style.fontSize = '18px';
                    feedback.style.textAlign = 'center';
                    feedback.style.lineHeight = '40px';
                }
                
                document.body.appendChild(feedback);
                
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                }, 300);
            }
            
            gameContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStartTime = performance.now();
                const touch = e.touches[0];
                touchStartPos = { x: touch.clientX, y: touch.clientY };
                
                // Setup long press detection (pause or hard drop based on zone)
                const startZone = getTouchZone(touch.clientX, touch.clientY);
                longPressTimer = setTimeout(() => {
                    if (longPressTimer) {
                        // Trigger haptic feedback if supported
                        if ('vibrate' in navigator) {
                            navigator.vibrate(100);
                        }
                        
                        if (startZone === 'bottom' && gameRunning) {
                            // Bottom zone long press = hard drop
                            hardDrop();
                            showZoneFeedback('bottom', touch.clientX, touch.clientY);
                            console.log('Long press: bottom zone -> hard drop');
                        } else {
                            // All other zones = pause/unpause game
                            gameRunning = !gameRunning;
                            if (gameRunning) {
                                gameLoop = requestAnimationFrame(gameUpdate);
                            } else if (gameLoop) {
                                cancelAnimationFrame(gameLoop);
                                gameLoop = null;
                            }
                            console.log('Long press: Game ' + (gameRunning ? 'unpaused' : 'paused'));
                        }
                        longPressTimer = null;
                    }
                }, 500);
                
                // Handle double-tap detection for grid zone only
                const zone = getTouchZone(touch.clientX, touch.clientY);
                if (zone === 'grid') {
                    const now = performance.now();
                    const timeSinceLastTap = now - lastTapTime;
                    
                    if (timeSinceLastTap < 250) {
                        // Double tap detected in grid - cancel single tap and execute hard drop
                        if (singleTapTimer) {
                            clearTimeout(singleTapTimer);
                            singleTapTimer = null;
                        }
                        if (gameRunning) {
                            hardDrop();
                            showZoneFeedback('grid', touch.clientX, touch.clientY);
                            console.log('Zone: grid double-tap -> hard drop');
                        }
                        lastTapTime = 0; // Reset to prevent triple-tap issues
                    } else {
                        lastTapTime = now;
                    }
                }
                
            }, { passive: false });
            
            gameContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                // Cancel long press if moving
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }, { passive: false });
            
            gameContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                // Cancel long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (!gameRunning) return;
                
                const endTime = performance.now();
                const duration = endTime - touchStartTime;
                const touch = e.changedTouches[0];
                const endPos = { x: touch.clientX, y: touch.clientY };
                
                const deltaX = endPos.x - touchStartPos.x;
                const deltaY = endPos.y - touchStartPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Only process taps (not swipes)
                if (distance < 20 && duration < 200) {
                    const zone = getTouchZone(touch.clientX, touch.clientY);
                    
                    if (zone === 'grid') {
                        // Grid tap - rotate piece (with delay for double-tap detection)
                        singleTapTimer = setTimeout(() => {
                            if (gameRunning) {
                                rotatePiece();
                                showZoneFeedback('grid', touch.clientX, touch.clientY);
                                console.log('Zone: grid tap -> rotate');
                            }
                            singleTapTimer = null;
                        }, 250);
                    } else if (zone === 'left') {
                        // Left zone tap - move piece left
                        movePiece(-1, 0);
                        showZoneFeedback('left', touch.clientX, touch.clientY);
                        console.log('Zone: left tap -> move left');
                    } else if (zone === 'right') {
                        // Right zone tap - move piece right
                        movePiece(1, 0);
                        showZoneFeedback('right', touch.clientX, touch.clientY);
                        console.log('Zone: right tap -> move right');
                    } else if (zone === 'bottom') {
                        // Bottom zone tap - soft drop (move down one row)
                        movePiece(0, 1);
                        showZoneFeedback('bottom', touch.clientX, touch.clientY);
                        console.log('Zone: bottom tap -> soft drop');
                    }
                }
            }, { passive: false });
            
            console.log('Zone-based touch controls setup complete');
        }
        

        
        // Handle orientation changes for mobile
        function handleOrientationChange() {
            if (!isMobile) return;
            
            setTimeout(() => {
                initializeMobile();
                updateMobileLayout();
                console.log('Layout updated for orientation change');
            }, 200);
        }
        
        // PWA Service Worker Registration
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('New service worker available, reloading...');
                                    // Auto-reload for updates (in production, you might want to prompt user)
                                    window.location.reload();
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                    });
            }
        }
        
        // PWA Install Prompt
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA install prompt available');
            e.preventDefault();
            deferredPrompt = e;
            
            // Show custom install button (could be added to UI later)
            if (isMobile) {
                console.log('PWA: Ready for installation on mobile device');
            }
        });
        
        window.addEventListener('appinstalled', (evt) => {
            console.log('PWA: App was installed successfully');
            deferredPrompt = null;
        });
        
        // Initialize the game when page loads
        window.addEventListener('load', function() {
            // Register service worker first
            registerServiceWorker();
            
            initializeBoard();
            setupMobileControls();
            console.log('Game initialized successfully');
            
            // Start the game automatically
            setTimeout(() => {
                startGame();
            }, 1000);
        });
        
        // Keyboard event listener (desktop)
        window.addEventListener('keydown', handleKeyDown);
        
        // Orientation change listener (mobile)
        window.addEventListener('orientationchange', handleOrientationChange);
        window.addEventListener('resize', handleOrientationChange);
    </script>
</body>
</html> 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Cache-busting headers -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>Tetris Turbo - Tron Edition</title>
    
    <style>
        /* Tron aesthetic base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000000;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .game-board {
            width: 300px;
            height: 600px;
            border: 2px solid #00ffff;
            border-radius: 5px;
            box-shadow: 0 0 20px #00ffff;
            position: relative;
            overflow: hidden;
        }
        
        .game-info {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 200px;
        }
        
        .score-display {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: 18px;
            font-weight: bold;
        }
        
        .level-display {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-size: 18px;
            font-weight: bold;
        }
        
        .version-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #666;
            font-size: 10px;
        }
        
        /* Grid cell styles */
        .cell {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .cell.filled {
            border: 1px solid currentColor;
            box-shadow: 0 0 5px currentColor;
        }
        
        /* Piece colors with glow effects */
        .cyan { color: #00ffff; background: rgba(0, 255, 255, 0.3); }
        .orange { color: #ff6600; background: rgba(255, 102, 0, 0.3); }
        .green { color: #00ff00; background: rgba(0, 255, 0, 0.3); }
        .pink { color: #ff0099; background: rgba(255, 0, 153, 0.3); }
        .blue { color: #0099ff; background: rgba(0, 153, 255, 0.3); }
        .yellow { color: #ffff00; background: rgba(255, 255, 0, 0.3); }
        .purple { color: #9900ff; background: rgba(153, 0, 255, 0.3); }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-board" id="gameBoard">
            <!-- Grid cells will be generated here -->
        </div>
        
        <div class="game-info">
            <div class="score-display">
                SCORE: <span id="score">0</span>
            </div>
            <div class="level-display">
                LEVEL: <span id="level">1</span>
            </div>
            <div class="controls" style="color: #666; font-size: 12px; margin-top: 20px;">
                <div>CONTROLS:</div>
                <div>← → ↓ ↑ : Move/Rotate</div>
                <div>A W S D : Move/Rotate</div>
                <div>SPACE : Hard Drop</div>
                <div>P : Pause</div>
                <div>R : Restart</div>
            </div>
        </div>
    </div>
    
    <div class="version-info">
        Tetris Turbo v1.0.0 - Cache Bust: tetris_turbo_v1_<?php echo time(); ?>
    </div>

    <script>
        // Game state and configuration
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const CELL_SIZE = 30;
        
        // Game board state array
        let board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null));
        
        // Game state
        let score = 0;
        let level = 1;
        let gameRunning = false;
        let currentPiece = null;
        let nextPiece = null;
        let gameLoop = null;
        
        // Tetris piece definitions with rotations
        const PIECES = {
            I: {
                color: 'cyan',
                rotations: [
                    [[1,1,1,1]],
                    [[1],[1],[1],[1]],
                    [[1,1,1,1]],
                    [[1],[1],[1],[1]]
                ]
            },
            O: {
                color: 'orange',
                rotations: [
                    [[1,1],[1,1]],
                    [[1,1],[1,1]],
                    [[1,1],[1,1]],
                    [[1,1],[1,1]]
                ]
            },
            T: {
                color: 'green',
                rotations: [
                    [[0,1,0],[1,1,1]],
                    [[1,0],[1,1],[1,0]],
                    [[1,1,1],[0,1,0]],
                    [[0,1],[1,1],[0,1]]
                ]
            },
            S: {
                color: 'pink',
                rotations: [
                    [[0,1,1],[1,1,0]],
                    [[1,0],[1,1],[0,1]],
                    [[0,1,1],[1,1,0]],
                    [[1,0],[1,1],[0,1]]
                ]
            },
            Z: {
                color: 'blue',
                rotations: [
                    [[1,1,0],[0,1,1]],
                    [[0,1],[1,1],[1,0]],
                    [[1,1,0],[0,1,1]],
                    [[0,1],[1,1],[1,0]]
                ]
            },
            J: {
                color: 'yellow',
                rotations: [
                    [[1,0,0],[1,1,1]],
                    [[1,1],[1,0],[1,0]],
                    [[1,1,1],[0,0,1]],
                    [[0,1],[0,1],[1,1]]
                ]
            },
            L: {
                color: 'purple',
                rotations: [
                    [[0,0,1],[1,1,1]],
                    [[1,0],[1,0],[1,1]],
                    [[1,1,1],[1,0,0]],
                    [[1,1],[0,1],[0,1]]
                ]
            }
        };
        
        // Version tracking for cache debugging
        console.log('Tetris Turbo loaded - Version 1.0.0');
        console.log('Cache Bust ID: tetris_turbo_v1');
        console.log('Piece definitions loaded:', Object.keys(PIECES).length, 'pieces');
        
        // Initialize the game board
        function initializeBoard() {
            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            
            // Create 10x20 grid
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${row}-${col}`;
                    cell.style.left = `${col * CELL_SIZE}px`;
                    cell.style.top = `${row * CELL_SIZE}px`;
                    gameBoard.appendChild(cell);
                }
            }
            
            console.log('Game board initialized with', BOARD_WIDTH * BOARD_HEIGHT, 'cells');
        }
        
        // Single method for updating cells (following testing requirements)
        function updateCell(row, col, color = null, glow = false) {
            const cell = document.getElementById(`cell-${row}-${col}`);
            if (!cell) return false;
            
            // Clear previous classes
            cell.className = 'cell';
            
            if (color) {
                cell.classList.add('filled', color);
                board[row][col] = color;
            } else {
                board[row][col] = null;
            }
            
            return true;
        }
        
        // Single method for rendering the entire board (batch updates)
        function renderBoard() {
            const startTime = performance.now();
            let updatedCells = 0;
            
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    if (updateCell(row, col, board[row][col])) {
                        updatedCells++;
                    }
                }
            }
            
            // Force repaint for smooth rendering
            document.getElementById('gameBoard').offsetHeight;
            
            const endTime = performance.now();
            console.log(`Board rendered: ${updatedCells} cells in ${(endTime - startTime).toFixed(2)}ms`);
        }
        
        // Create a new random piece
        function createPiece() {
            const pieceTypes = Object.keys(PIECES);
            const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
            
            return {
                type: randomType,
                rotation: 0,
                x: Math.floor(BOARD_WIDTH / 2) - 1,
                y: 0,
                shape: PIECES[randomType].rotations[0],
                color: PIECES[randomType].color
            };
        }
        
        // Draw a piece on the board (visual representation)
        function drawPiece(piece, x, y) {
            if (!piece) return;
            
            const shape = PIECES[piece.type].rotations[piece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH) {
                            updateCell(boardRow, boardCol, piece.color);
                        }
                    }
                }
            }
        }
        
        // Clear a piece from the board
        function clearPiece(piece, x, y) {
            if (!piece) return;
            
            const shape = PIECES[piece.type].rotations[piece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH &&
                            board[boardRow][boardCol] === piece.color) {
                            updateCell(boardRow, boardCol, null);
                        }
                    }
                }
            }
        }
        
        // Check if a piece can be placed at a position
        function canPlacePiece(piece, x, y, rotation = null) {
            if (!piece) return false;
            
            const currentRotation = rotation !== null ? rotation : piece.rotation;
            const shape = PIECES[piece.type].rotations[currentRotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        // Check boundaries
                        if (boardRow < 0 || boardRow >= BOARD_HEIGHT || 
                            boardCol < 0 || boardCol >= BOARD_WIDTH) {
                            return false;
                        }
                        
                        // Check collision with existing pieces
                        if (board[boardRow][boardCol] !== null) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Update score display
        function updateScore(newScore = null) {
            if (newScore !== null) {
                score = newScore;
            }
            document.getElementById('score').textContent = score;
        }
        
        // Update level display
        function updateLevel(newLevel = null) {
            if (newLevel !== null) {
                level = newLevel;
            }
            document.getElementById('level').textContent = level;
        }
        
        // Single method for moving pieces (following testing requirements)
        function movePiece(dx, dy) {
            if (!currentPiece || !gameRunning) return false;
            
            // Clear current piece from board
            clearPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            const newX = currentPiece.x + dx;
            const newY = currentPiece.y + dy;
            
            if (canPlacePiece(currentPiece, newX, newY)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return true;
            } else {
                // Can't move, restore piece
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                
                // If trying to move down and can't, lock the piece
                if (dy > 0) {
                    lockPiece();
                }
                return false;
            }
        }
        
        // Rotate the current piece
        function rotatePiece() {
            if (!currentPiece || !gameRunning) return false;
            
            clearPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            const newRotation = (currentPiece.rotation + 1) % 4;
            
            if (canPlacePiece(currentPiece, currentPiece.x, currentPiece.y, newRotation)) {
                currentPiece.rotation = newRotation;
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return true;
            } else {
                // Try wall kicks (move left/right if rotation blocked)
                for (let kick of [-1, 1, -2, 2]) {
                    if (canPlacePiece(currentPiece, currentPiece.x + kick, currentPiece.y, newRotation)) {
                        currentPiece.x += kick;
                        currentPiece.rotation = newRotation;
                        drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                        return true;
                    }
                }
                
                // Couldn't rotate, restore piece
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return false;
            }
        }
        
        // Hard drop - instant placement
        function hardDrop() {
            if (!currentPiece || !gameRunning) return;
            
            while (movePiece(0, 1)) {
                // Keep moving down until we can't
            }
            // movePiece will automatically call lockPiece when it can't move down
        }
        
        // Lock current piece in place and spawn new piece
        function lockPiece() {
            if (!currentPiece) return;
            
            // Piece is already drawn on board, just update the board array
            const shape = PIECES[currentPiece.type].rotations[currentPiece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = currentPiece.y + row;
                        const boardCol = currentPiece.x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH) {
                            board[boardRow][boardCol] = currentPiece.color;
                        }
                    }
                }
            }
            
            // Check for completed lines
            checkLines();
            
            // Spawn new piece
            currentPiece = nextPiece || createPiece();
            nextPiece = createPiece();
            
            // Check game over
            if (!canPlacePiece(currentPiece, currentPiece.x, currentPiece.y)) {
                gameOver();
                return;
            }
            
            drawPiece(currentPiece, currentPiece.x, currentPiece.y);
        }
        
        // Check for completed lines
        function checkLines() {
            const completedLines = [];
            
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                if (board[row].every(cell => cell !== null)) {
                    completedLines.push(row);
                }
            }
            
            if (completedLines.length > 0) {
                // Clear completed lines
                completedLines.forEach(row => {
                    board.splice(row, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(null));
                });
                
                // Update score
                const points = [0, 100, 300, 500, 800][completedLines.length] * level;
                updateScore(score + points);
                
                // Check level progression
                const newLevel = Math.floor(score / 1000) + 1;
                if (newLevel !== level) {
                    updateLevel(newLevel);
                }
                
                // Re-render board after line clear
                renderBoard();
                
                console.log(`Cleared ${completedLines.length} lines, +${points} points`);
            }
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
            console.log('Game Over! Final Score:', score);
            // TODO: Add game over screen
        }
        
        // Start new game
        function startGame() {
            // Reset game state
            board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null));
            score = 0;
            level = 1;
            updateScore();
            updateLevel();
            
            // Create first pieces
            currentPiece = createPiece();
            nextPiece = createPiece();
            
            gameRunning = true;
            
            // Clear board and draw first piece
            renderBoard();
            drawPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            // Start game loop
            gameLoop = requestAnimationFrame(gameUpdate);
            
            console.log('Game started!');
        }
        
        // Game timing variables
        let lastDrop = 0;
        
        // Main game loop
        function gameUpdate() {
            if (!gameRunning) return;
            
            // Auto-drop logic
            const now = Date.now();
            const dropInterval = Math.max(100, 1000 - (level - 1) * 100);
            
            if (now - lastDrop > dropInterval) {
                movePiece(0, 1);
                lastDrop = now;
            }
            
            gameLoop = requestAnimationFrame(gameUpdate);
        }
        
        // Keyboard input handling
        function handleKeyDown(event) {
            if (!gameRunning) {
                if (event.key === 'r' || event.key === 'R') {
                    startGame();
                }
                return;
            }
            
            switch(event.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    event.preventDefault();
                    movePiece(-1, 0);
                    break;
                    
                case 'ArrowRight':
                case 'd':
                case 'D':
                    event.preventDefault();
                    movePiece(1, 0);
                    break;
                    
                case 'ArrowDown':
                case 's':
                case 'S':
                    event.preventDefault();
                    movePiece(0, 1);
                    break;
                    
                case 'ArrowUp':
                case 'w':
                case 'W':
                    event.preventDefault();
                    rotatePiece();
                    break;
                    
                case ' ':
                    event.preventDefault();
                    hardDrop();
                    break;
                    
                case 'p':
                case 'P':
                    event.preventDefault();
                    gameRunning = !gameRunning;
                    if (gameRunning) {
                        gameLoop = requestAnimationFrame(gameUpdate);
                    } else if (gameLoop) {
                        cancelAnimationFrame(gameLoop);
                        gameLoop = null;
                    }
                    console.log(gameRunning ? 'Game unpaused' : 'Game paused');
                    break;
                    
                case 'r':
                case 'R':
                    event.preventDefault();
                    startGame();
                    break;
            }
        }
        
        // Initialize the game when page loads
        window.addEventListener('load', function() {
            initializeBoard();
            console.log('Game initialized successfully');
            
            // Start the game automatically
            setTimeout(() => {
                startGame();
            }, 1000);
        });
        
        // Keyboard event listener
        window.addEventListener('keydown', handleKeyDown);
    </script>
</body>
</html> 
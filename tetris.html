<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    
    <!-- Cache-busting headers -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Mobile-specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Tetris Turbo">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <title>Tetris Turbo - Mobile Edition</title>
    
    <style>
        /* Mobile-first Tron aesthetic */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000000;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
            touch-action: manipulation;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
            gap: 10px;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .game-board {
            flex: 1;
            max-width: 100%;
            margin: 0 auto;
            border: 2px solid #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff;
            position: relative;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.8);
        }
        
        .touch-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            height: 120px;
        }
        
        .game-info {
            display: none; /* Hidden on mobile, moved to header */
        }
        
        .score-display {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: clamp(14px, 4vw, 18px);
            font-weight: bold;
        }
        
        .level-display {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-size: clamp(14px, 4vw, 18px);
            font-weight: bold;
        }
        
        .touch-button {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            border-radius: 8px;
            color: #00ffff;
            font-family: inherit;
            font-size: clamp(12px, 3vw, 16px);
            font-weight: bold;
            text-shadow: 0 0 5px #00ffff;
            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 44px;
            transition: all 0.1s ease;
        }
        
        .touch-button:active {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px #00ffff;
            transform: scale(0.95);
        }
        
        .touch-button.primary {
            background: rgba(0, 255, 0, 0.2);
            border-color: #00ff00;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        
        .touch-button.primary:active {
            background: rgba(0, 255, 0, 0.4);
            box-shadow: 0 0 10px #00ff00;
        }
        
        .version-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #666;
            font-size: 10px;
        }
        
        /* Responsive grid cell styles */
        .cell {
            position: absolute;
            border: 1px solid rgba(0, 255, 255, 0.1);
            transition: all 0.1s ease;
        }
        
        .cell.filled {
            border: 1px solid currentColor;
            box-shadow: 0 0 5px currentColor;
        }
        
        /* Desktop breakpoint */
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                justify-content: center;
                align-items: center;
                padding: 20px;
            }
            
            .game-header {
                display: none;
            }
            
            .game-board {
                width: 300px;
                height: 600px;
                flex: none;
            }
            
            .game-info {
                display: flex;
                flex-direction: column;
                gap: 20px;
                min-width: 200px;
            }
            
            .touch-controls {
                display: none;
            }
            
            .score-display,
            .level-display {
                font-size: 18px;
            }
        }
        
        /* Piece colors with glow effects */
        .cyan { color: #00ffff; background: rgba(0, 255, 255, 0.3); }
        .orange { color: #ff6600; background: rgba(255, 102, 0, 0.3); }
        .green { color: #00ff00; background: rgba(0, 255, 0, 0.3); }
        .pink { color: #ff0099; background: rgba(255, 0, 153, 0.3); }
        .blue { color: #0099ff; background: rgba(0, 153, 255, 0.3); }
        .yellow { color: #ffff00; background: rgba(255, 255, 0, 0.3); }
        .purple { color: #9900ff; background: rgba(153, 0, 255, 0.3); }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Mobile header with score/level -->
        <div class="game-header">
            <div class="score-display">
                SCORE: <span id="score">0</span>
            </div>
            <div class="level-display">
                LEVEL: <span id="level">1</span>
            </div>
        </div>
        
        <!-- Game board -->
        <div class="game-board" id="gameBoard">
            <!-- Grid cells will be generated here -->
        </div>
        
        <!-- Touch controls for mobile -->
        <div class="touch-controls">
            <button class="touch-button" id="btnLeft">◀</button>
            <button class="touch-button" id="btnRotate">↻</button>
            <button class="touch-button" id="btnRight">▶</button>
            <button class="touch-button primary" id="btnDrop">⬇</button>
            <button class="touch-button" id="btnPause">⏸</button>
            <button class="touch-button" id="btnRestart">↻</button>
        </div>
        
        <!-- Desktop info panel (hidden on mobile) -->
        <div class="game-info">
            <div class="score-display">
                SCORE: <span id="scoreDesktop">0</span>
            </div>
            <div class="level-display">
                LEVEL: <span id="levelDesktop">1</span>
            </div>
            <div class="controls" style="color: #666; font-size: 12px; margin-top: 20px;">
                <div>CONTROLS:</div>
                <div>← → ↓ ↑ : Move/Rotate</div>
                <div>A W S D : Move/Rotate</div>
                <div>SPACE : Hard Drop</div>
                <div>P : Pause</div>
                <div>R : Restart</div>
            </div>
        </div>
    </div>
    
    <div class="version-info">
        Tetris Turbo v1.0.0 - Cache Bust: tetris_turbo_v1_<?php echo time(); ?>
    </div>

    <script>
        // Game state and configuration
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        let CELL_SIZE = 30; // Dynamic cell size for mobile
        let isMobile = false;
        
        // Game board state array
        let board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null));
        
        // Game state
        let score = 0;
        let level = 1;
        let gameRunning = false;
        let currentPiece = null;
        let nextPiece = null;
        let gameLoop = null;
        
        // Tetris piece definitions with rotations
        const PIECES = {
            I: {
                color: 'cyan',
                rotations: [
                    [[1,1,1,1]],
                    [[1],[1],[1],[1]],
                    [[1,1,1,1]],
                    [[1],[1],[1],[1]]
                ]
            },
            O: {
                color: 'orange',
                rotations: [
                    [[1,1],[1,1]],
                    [[1,1],[1,1]],
                    [[1,1],[1,1]],
                    [[1,1],[1,1]]
                ]
            },
            T: {
                color: 'green',
                rotations: [
                    [[0,1,0],[1,1,1]],
                    [[1,0],[1,1],[1,0]],
                    [[1,1,1],[0,1,0]],
                    [[0,1],[1,1],[0,1]]
                ]
            },
            S: {
                color: 'pink',
                rotations: [
                    [[0,1,1],[1,1,0]],
                    [[1,0],[1,1],[0,1]],
                    [[0,1,1],[1,1,0]],
                    [[1,0],[1,1],[0,1]]
                ]
            },
            Z: {
                color: 'blue',
                rotations: [
                    [[1,1,0],[0,1,1]],
                    [[0,1],[1,1],[1,0]],
                    [[1,1,0],[0,1,1]],
                    [[0,1],[1,1],[1,0]]
                ]
            },
            J: {
                color: 'yellow',
                rotations: [
                    [[1,0,0],[1,1,1]],
                    [[1,1],[1,0],[1,0]],
                    [[1,1,1],[0,0,1]],
                    [[0,1],[0,1],[1,1]]
                ]
            },
            L: {
                color: 'purple',
                rotations: [
                    [[0,0,1],[1,1,1]],
                    [[1,0],[1,0],[1,1]],
                    [[1,1,1],[1,0,0]],
                    [[1,1],[0,1],[0,1]]
                ]
            }
        };
        
        // Version tracking for cache debugging
        console.log('Tetris Turbo Mobile loaded - Version 2.0.0');
        console.log('Cache Bust ID: tetris_turbo_mobile_v2');
        console.log('Piece definitions loaded:', Object.keys(PIECES).length, 'pieces');
        
        // Mobile detection and initialization
        function initializeMobile() {
            // Detect mobile device
            isMobile = window.innerWidth < 768 || ('ontouchstart' in window);
            
            // Calculate responsive cell size for mobile
            if (isMobile) {
                const gameBoard = document.getElementById('gameBoard');
                const containerWidth = window.innerWidth - 40; // Account for padding
                const containerHeight = window.innerHeight - 200; // Account for header/controls
                
                const cellSizeByWidth = Math.floor(containerWidth / BOARD_WIDTH);
                const cellSizeByHeight = Math.floor(containerHeight / BOARD_HEIGHT);
                
                CELL_SIZE = Math.min(cellSizeByWidth, cellSizeByHeight, 35); // Max 35px on mobile
                
                // Update game board size
                gameBoard.style.width = (BOARD_WIDTH * CELL_SIZE) + 'px';
                gameBoard.style.height = (BOARD_HEIGHT * CELL_SIZE) + 'px';
                
                console.log('Mobile mode: Cell size =', CELL_SIZE + 'px');
            }
            
            return isMobile;
        }
        
        // Single method for updating mobile layout
        function updateMobileLayout() {
            if (!isMobile) return;
            
            // Update all cell positions with new size
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    if (cell) {
                        cell.style.left = (col * CELL_SIZE) + 'px';
                        cell.style.top = (row * CELL_SIZE) + 'px';
                        cell.style.width = CELL_SIZE + 'px';
                        cell.style.height = CELL_SIZE + 'px';
                    }
                }
            }
        }
        
        // Initialize the game board
        function initializeBoard() {
            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            
            // Initialize mobile layout first
            initializeMobile();
            
            // Create 10x20 grid with responsive sizing
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${row}-${col}`;
                    cell.style.left = (col * CELL_SIZE) + 'px';
                    cell.style.top = (row * CELL_SIZE) + 'px';
                    cell.style.width = CELL_SIZE + 'px';
                    cell.style.height = CELL_SIZE + 'px';
                    gameBoard.appendChild(cell);
                }
            }
            
            console.log('Game board initialized with', BOARD_WIDTH * BOARD_HEIGHT, 'cells');
            console.log('Mobile mode:', isMobile, '| Cell size:', CELL_SIZE + 'px');
        }
        
        // Single method for updating cells (following testing requirements)
        function updateCell(row, col, color = null, glow = false) {
            const cell = document.getElementById(`cell-${row}-${col}`);
            if (!cell) return false;
            
            // Clear previous classes
            cell.className = 'cell';
            
            if (color) {
                cell.classList.add('filled', color);
                board[row][col] = color;
            } else {
                board[row][col] = null;
            }
            
            return true;
        }
        
        // Single method for rendering the entire board (batch updates)
        function renderBoard() {
            const startTime = performance.now();
            let updatedCells = 0;
            
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    if (updateCell(row, col, board[row][col])) {
                        updatedCells++;
                    }
                }
            }
            
            // Force repaint for smooth rendering
            document.getElementById('gameBoard').offsetHeight;
            
            const endTime = performance.now();
            console.log(`Board rendered: ${updatedCells} cells in ${(endTime - startTime).toFixed(2)}ms`);
        }
        
        // Create a new random piece
        function createPiece() {
            const pieceTypes = Object.keys(PIECES);
            const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
            
            return {
                type: randomType,
                rotation: 0,
                x: Math.floor(BOARD_WIDTH / 2) - 1,
                y: 0,
                shape: PIECES[randomType].rotations[0],
                color: PIECES[randomType].color
            };
        }
        
        // Draw a piece on the board (visual representation)
        function drawPiece(piece, x, y) {
            if (!piece) return;
            
            const shape = PIECES[piece.type].rotations[piece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH) {
                            updateCell(boardRow, boardCol, piece.color);
                        }
                    }
                }
            }
        }
        
        // Clear a piece from the board
        function clearPiece(piece, x, y) {
            if (!piece) return;
            
            const shape = PIECES[piece.type].rotations[piece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH &&
                            board[boardRow][boardCol] === piece.color) {
                            updateCell(boardRow, boardCol, null);
                        }
                    }
                }
            }
        }
        
        // Check if a piece can be placed at a position
        function canPlacePiece(piece, x, y, rotation = null) {
            if (!piece) return false;
            
            const currentRotation = rotation !== null ? rotation : piece.rotation;
            const shape = PIECES[piece.type].rotations[currentRotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        
                        // Check boundaries
                        if (boardRow < 0 || boardRow >= BOARD_HEIGHT || 
                            boardCol < 0 || boardCol >= BOARD_WIDTH) {
                            return false;
                        }
                        
                        // Check collision with existing pieces
                        if (board[boardRow][boardCol] !== null) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Update score display (mobile and desktop)
        function updateScore(newScore = null) {
            if (newScore !== null) {
                score = newScore;
            }
            
            // Update mobile score
            const mobileScore = document.getElementById('score');
            if (mobileScore) {
                mobileScore.textContent = score;
            }
            
            // Update desktop score
            const desktopScore = document.getElementById('scoreDesktop');
            if (desktopScore) {
                desktopScore.textContent = score;
            }
        }
        
        // Update level display (mobile and desktop)
        function updateLevel(newLevel = null) {
            if (newLevel !== null) {
                level = newLevel;
            }
            
            // Update mobile level
            const mobileLevel = document.getElementById('level');
            if (mobileLevel) {
                mobileLevel.textContent = level;
            }
            
            // Update desktop level
            const desktopLevel = document.getElementById('levelDesktop');
            if (desktopLevel) {
                desktopLevel.textContent = level;
            }
        }
        
        // Single method for moving pieces (following testing requirements)
        function movePiece(dx, dy) {
            if (!currentPiece || !gameRunning) return false;
            
            // Clear current piece from board
            clearPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            const newX = currentPiece.x + dx;
            const newY = currentPiece.y + dy;
            
            if (canPlacePiece(currentPiece, newX, newY)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return true;
            } else {
                // Can't move, restore piece
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                
                // If trying to move down and can't, lock the piece
                if (dy > 0) {
                    lockPiece();
                }
                return false;
            }
        }
        
        // Rotate the current piece
        function rotatePiece() {
            if (!currentPiece || !gameRunning) return false;
            
            clearPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            const newRotation = (currentPiece.rotation + 1) % 4;
            
            if (canPlacePiece(currentPiece, currentPiece.x, currentPiece.y, newRotation)) {
                currentPiece.rotation = newRotation;
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return true;
            } else {
                // Try wall kicks (move left/right if rotation blocked)
                for (let kick of [-1, 1, -2, 2]) {
                    if (canPlacePiece(currentPiece, currentPiece.x + kick, currentPiece.y, newRotation)) {
                        currentPiece.x += kick;
                        currentPiece.rotation = newRotation;
                        drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                        return true;
                    }
                }
                
                // Couldn't rotate, restore piece
                drawPiece(currentPiece, currentPiece.x, currentPiece.y);
                return false;
            }
        }
        
        // Hard drop - instant placement
        function hardDrop() {
            if (!currentPiece || !gameRunning) return;
            
            while (movePiece(0, 1)) {
                // Keep moving down until we can't
            }
            // movePiece will automatically call lockPiece when it can't move down
        }
        
        // Lock current piece in place and spawn new piece
        function lockPiece() {
            if (!currentPiece) return;
            
            // Piece is already drawn on board, just update the board array
            const shape = PIECES[currentPiece.type].rotations[currentPiece.rotation];
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = currentPiece.y + row;
                        const boardCol = currentPiece.x + col;
                        
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && 
                            boardCol >= 0 && boardCol < BOARD_WIDTH) {
                            board[boardRow][boardCol] = currentPiece.color;
                        }
                    }
                }
            }
            
            // Check for completed lines
            checkLines();
            
            // Spawn new piece
            currentPiece = nextPiece || createPiece();
            nextPiece = createPiece();
            
            // Check game over
            if (!canPlacePiece(currentPiece, currentPiece.x, currentPiece.y)) {
                gameOver();
                return;
            }
            
            drawPiece(currentPiece, currentPiece.x, currentPiece.y);
        }
        
        // Check for completed lines
        function checkLines() {
            const completedLines = [];
            
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                if (board[row].every(cell => cell !== null)) {
                    completedLines.push(row);
                }
            }
            
            if (completedLines.length > 0) {
                // Clear completed lines
                completedLines.forEach(row => {
                    board.splice(row, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(null));
                });
                
                // Update score
                const points = [0, 100, 300, 500, 800][completedLines.length] * level;
                updateScore(score + points);
                
                // Check level progression
                const newLevel = Math.floor(score / 1000) + 1;
                if (newLevel !== level) {
                    updateLevel(newLevel);
                }
                
                // Re-render board after line clear
                renderBoard();
                
                console.log(`Cleared ${completedLines.length} lines, +${points} points`);
            }
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
            console.log('Game Over! Final Score:', score);
            // TODO: Add game over screen
        }
        
        // Start new game
        function startGame() {
            // Reset game state
            board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null));
            score = 0;
            level = 1;
            updateScore();
            updateLevel();
            
            // Create first pieces
            currentPiece = createPiece();
            nextPiece = createPiece();
            
            gameRunning = true;
            
            // Clear board and draw first piece
            renderBoard();
            drawPiece(currentPiece, currentPiece.x, currentPiece.y);
            
            // Start game loop
            gameLoop = requestAnimationFrame(gameUpdate);
            
            console.log('Game started!');
        }
        
        // Game timing variables
        let lastDrop = 0;
        
        // Main game loop
        function gameUpdate() {
            if (!gameRunning) return;
            
            // Auto-drop logic
            const now = Date.now();
            const dropInterval = Math.max(100, 1000 - (level - 1) * 100);
            
            if (now - lastDrop > dropInterval) {
                movePiece(0, 1);
                lastDrop = now;
            }
            
            gameLoop = requestAnimationFrame(gameUpdate);
        }
        
        // Keyboard input handling
        function handleKeyDown(event) {
            if (!gameRunning) {
                if (event.key === 'r' || event.key === 'R') {
                    startGame();
                }
                return;
            }
            
            switch(event.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    event.preventDefault();
                    movePiece(-1, 0);
                    break;
                    
                case 'ArrowRight':
                case 'd':
                case 'D':
                    event.preventDefault();
                    movePiece(1, 0);
                    break;
                    
                case 'ArrowDown':
                case 's':
                case 'S':
                    event.preventDefault();
                    movePiece(0, 1);
                    break;
                    
                case 'ArrowUp':
                case 'w':
                case 'W':
                    event.preventDefault();
                    rotatePiece();
                    break;
                    
                case ' ':
                    event.preventDefault();
                    hardDrop();
                    break;
                    
                case 'p':
                case 'P':
                    event.preventDefault();
                    gameRunning = !gameRunning;
                    if (gameRunning) {
                        gameLoop = requestAnimationFrame(gameUpdate);
                    } else if (gameLoop) {
                        cancelAnimationFrame(gameLoop);
                        gameLoop = null;
                    }
                    console.log(gameRunning ? 'Game unpaused' : 'Game paused');
                    break;
                    
                case 'r':
                case 'R':
                    event.preventDefault();
                    startGame();
                    break;
            }
        }
        
        // Touch event handling for mobile
        function setupTouchControls() {
            if (!isMobile) return;
            
            const buttons = {
                btnLeft: () => movePiece(-1, 0),
                btnRight: () => movePiece(1, 0),
                btnRotate: () => rotatePiece(),
                btnDrop: () => hardDrop(),
                btnPause: () => {
                    gameRunning = !gameRunning;
                    if (gameRunning) {
                        gameLoop = requestAnimationFrame(gameUpdate);
                    } else if (gameLoop) {
                        cancelAnimationFrame(gameLoop);
                        gameLoop = null;
                    }
                    console.log(gameRunning ? 'Game unpaused' : 'Game paused');
                },
                btnRestart: () => startGame()
            };
            
            // Add touch event listeners to buttons
            Object.keys(buttons).forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (button) {
                    // Use touchstart for immediate response
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        if (gameRunning || buttonId === 'btnRestart' || buttonId === 'btnPause') {
                            buttons[buttonId]();
                        }
                    }, { passive: false });
                    
                    // Prevent double-firing on click
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                    });
                }
            });
            
            // Setup gesture recognition on game board
            setupGestureRecognition();
            
            console.log('Touch controls setup complete');
        }
        
        // Advanced gesture recognition for game board
        function setupGestureRecognition() {
            const gameBoard = document.getElementById('gameBoard');
            let touchStartTime = 0;
            let touchStartPos = { x: 0, y: 0 };
            let longPressTimer = null;
            
            gameBoard.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStartTime = performance.now();
                const touch = e.touches[0];
                touchStartPos = { x: touch.clientX, y: touch.clientY };
                
                // Setup long press detection for pause
                longPressTimer = setTimeout(() => {
                    if (longPressTimer) {
                        // Trigger haptic feedback if supported
                        if ('vibrate' in navigator) {
                            navigator.vibrate(100);
                        }
                        
                        // Pause/unpause game
                        gameRunning = !gameRunning;
                        if (gameRunning) {
                            gameLoop = requestAnimationFrame(gameUpdate);
                        } else if (gameLoop) {
                            cancelAnimationFrame(gameLoop);
                            gameLoop = null;
                        }
                        console.log('Long press: Game ' + (gameRunning ? 'unpaused' : 'paused'));
                        longPressTimer = null;
                    }
                }, 500);
                
            }, { passive: false });
            
            gameBoard.addEventListener('touchmove', (e) => {
                e.preventDefault();
                // Cancel long press if moving
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }, { passive: false });
            
            gameBoard.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                // Cancel long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (!gameRunning) return;
                
                const endTime = performance.now();
                const duration = endTime - touchStartTime;
                const touch = e.changedTouches[0];
                const endPos = { x: touch.clientX, y: touch.clientY };
                
                const deltaX = endPos.x - touchStartPos.x;
                const deltaY = endPos.y - touchStartPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Quick tap = rotate
                if (distance < 20 && duration < 200) {
                    rotatePiece();
                    console.log('Gesture: tap -> rotate');
                    return;
                }
                
                // Double tap = hard drop (handled separately)
                // Swipe gestures
                if (distance > 30) {
                    const velocity = distance / duration;
                    
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal swipe
                        if (deltaX > 0) {
                            movePiece(1, 0); // Swipe right
                            console.log('Gesture: swipe right');
                        } else {
                            movePiece(-1, 0); // Swipe left
                            console.log('Gesture: swipe left');
                        }
                    } else if (deltaY > 0) {
                        // Swipe down = soft drop or hard drop based on velocity
                        if (velocity > 2) {
                            hardDrop();
                            console.log('Gesture: fast swipe down -> hard drop');
                        } else {
                            movePiece(0, 1);
                            console.log('Gesture: swipe down -> soft drop');
                        }
                    }
                }
            }, { passive: false });
            
            // Double tap detection
            let lastTapTime = 0;
            gameBoard.addEventListener('touchstart', (e) => {
                const now = performance.now();
                if (now - lastTapTime < 300) {
                    // Double tap detected
                    e.preventDefault();
                    if (gameRunning) {
                        hardDrop();
                        console.log('Gesture: double tap -> hard drop');
                    }
                }
                lastTapTime = now;
            }, { passive: false });
            
            console.log('Gesture recognition setup complete');
        }
        

        
        // Handle orientation changes for mobile
        function handleOrientationChange() {
            if (!isMobile) return;
            
            setTimeout(() => {
                initializeMobile();
                updateMobileLayout();
                console.log('Layout updated for orientation change');
            }, 200);
        }
        
        // PWA Service Worker Registration
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('New service worker available, reloading...');
                                    // Auto-reload for updates (in production, you might want to prompt user)
                                    window.location.reload();
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                    });
            }
        }
        
        // PWA Install Prompt
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA install prompt available');
            e.preventDefault();
            deferredPrompt = e;
            
            // Show custom install button (could be added to UI later)
            if (isMobile) {
                console.log('PWA: Ready for installation on mobile device');
            }
        });
        
        window.addEventListener('appinstalled', (evt) => {
            console.log('PWA: App was installed successfully');
            deferredPrompt = null;
        });
        
        // Initialize the game when page loads
        window.addEventListener('load', function() {
            // Register service worker first
            registerServiceWorker();
            
            initializeBoard();
            setupTouchControls();
            console.log('Game initialized successfully');
            
            // Start the game automatically
            setTimeout(() => {
                startGame();
            }, 1000);
        });
        
        // Keyboard event listener (desktop)
        window.addEventListener('keydown', handleKeyDown);
        
        // Orientation change listener (mobile)
        window.addEventListener('orientationchange', handleOrientationChange);
        window.addEventListener('resize', handleOrientationChange);
    </script>
</body>
</html> 